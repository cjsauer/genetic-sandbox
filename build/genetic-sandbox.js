/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\n__webpack_require__(1);\n\n__webpack_require__(2);\n\nvar _App = __webpack_require__(6);\n\nvar _App2 = _interopRequireDefault(_App);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Add systems to this list to include them in the processing loop\n\n\n// Load the main stylesheet\nvar systems = [];\n\n// Import and bootstrap the application!\n// Load main.html into the build folder using the webpack file-loader so that\n// it becomes the \"homepage\"\n\n\nvar app = new _App2.default(systems);\napp.initialize();\n\n// TODO: Implement a more formal game loop\napp.update();\n\nconsole.log(\"Genetic Sandbox is up and running!\");\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/main.js?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"index.html\";\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/file-loader?name=index.html!./src/main.html\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/main.html?./~/file-loader?name=index.html");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(3);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(5)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./reset.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./reset.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/styles/reset.css\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/styles/reset.css?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(4)();\n// imports\n\n\n// module\nexports.push([module.id, \"/* http://meyerweb.com/eric/tools/css/reset/\\n   v2.0 | 20110126\\n   License: none (public domain)\\n*/\\n\\nhtml, body, div, span, applet, object, iframe,\\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\\na, abbr, acronym, address, big, cite, code,\\ndel, dfn, em, img, ins, kbd, q, s, samp,\\nsmall, strike, strong, sub, sup, tt, var,\\nb, u, i, center,\\ndl, dt, dd, ol, ul, li,\\nfieldset, form, label, legend,\\ntable, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, embed,\\nfigure, figcaption, footer, header, hgroup,\\nmenu, nav, output, ruby, section, summary,\\ntime, mark, audio, video {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tborder: 0;\\n\\tfont-size: 100%;\\n\\tfont: inherit;\\n\\tvertical-align: baseline;\\n}\\n/* HTML5 display-role reset for older browsers */\\narticle, aside, details, figcaption, figure,\\nfooter, header, hgroup, menu, nav, section {\\n\\tdisplay: block;\\n}\\nbody {\\n\\tline-height: 1;\\n}\\nol, ul {\\n\\tlist-style: none;\\n}\\nblockquote, q {\\n\\tquotes: none;\\n}\\nblockquote:before, blockquote:after,\\nq:before, q:after {\\n\\tcontent: '';\\n\\tcontent: none;\\n}\\ntable {\\n\\tborder-collapse: collapse;\\n\\tborder-spacing: 0;\\n}\\n\", \"\"]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/styles/reset.css\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/styles/reset.css?./~/css-loader");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(true) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _HexGrid = __webpack_require__(7);\n\nvar _HexGrid2 = _interopRequireDefault(_HexGrid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The entry point of the entire application. App contains references to the\n * grid and an array of systems.\n * @see {HexGrid}\n * @see {ISystem}\n */\n\nvar App = function () {\n  /**\n   * Prepares the Genetic Sandbox application for bootstrapping.\n   * @param {Array.ISystem} systems - the systems to be included in the main\n   * processing loop\n   */\n\n  function App(systems) {\n    _classCallCheck(this, App);\n\n    /**\n     * A grid of tiles serving as the main stage of the simulation\n     * @type HexGrid\n     */\n    this.grid = new _HexGrid2.default(App.GRID_RADIUS);\n\n    /**\n     * Array of systems included in the main processing loop\n     * @type {Array.ISystem}\n     */\n    this.systems = systems;\n  }\n\n  /**\n   * Initializes every System in the systems array\n   */\n\n\n  _createClass(App, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      this.systems.forEach(function (system) {\n        system.initialize(_this.grid);\n      });\n    }\n\n    /**\n     * Updates every System in the systems array\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this2 = this;\n\n      this.systems.forEach(function (system) {\n        system.update(_this2.grid);\n      });\n    }\n  }]);\n\n  return App;\n}();\n\nApp.GRID_RADIUS = 25;\n\nexports.default = App;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/App.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/modules/App.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tile = __webpack_require__(8);\n\nvar _Tile2 = _interopRequireDefault(_Tile);\n\nvar _TilePropertyIndex = __webpack_require__(10);\n\nvar _TilePropertyIndex2 = _interopRequireDefault(_TilePropertyIndex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A 2D, hexagonal grid implementation with axial coordinate system.\n * Implementation details can be found [here]{@link http://goo.gl/nLO6sN}.\n * @see {@link Tile}\n */\n\nvar HexGrid = function () {\n  /**\n   * Constructs a new HexGrid of given radius. The pattern of tiles within the\n   * grid will then form a hexagon itself with (0,0) being the center.\n   * A grid of radius 0 is just a single hexagon, radius 1 is a single hexagon\n   * surrounded by 1 layer of hexagons, and so on...\n   * @example\n   * let myGrid = new HexGrid(10, {\n   *    biome: \"desert\"\n   * });\n   * @param {number} radius - Number of tiles from center of grid to the edge,\n   * not counting the center tile\n   * @param {Object} [defaultTileProps={}] - Default properties that all Tiles\n   * will be initialized with\n   */\n\n  function HexGrid(radius) {\n    var defaultTileProps = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, HexGrid);\n\n    /* Generate a hex grid. We'll use the constraint in cubic coordinates\n     * that x + y + z = 0 to decide where hexes are to be placed before\n     * converting to axial coordinates for storage.\n     * Note that within this file (x, y, z) refer to cubic coordinates, while\n     * (q, r) refer to axial coordinates. The distinction is only present\n     * within this file for clarity; everywhere else in the source will use\n     * (x, y) notation in favor of familiarity.\n     */\n    var tiles = [];\n    var x = void 0,\n        y = void 0,\n        z = void 0,\n        q = void 0,\n        r = void 0;\n    for (x = -radius; x <= radius; x++) {\n      for (y = -radius; y <= radius; y++) {\n        for (z = -radius; z <= radius; z++) {\n          if (x + y + z === 0) {\n            var _HexGrid$_cubicToAxia = HexGrid._cubicToAxial(x, y, z);\n            // This is a valid hex. Instantiate and store in the tiles array.\n\n\n            q = _HexGrid$_cubicToAxia.q;\n            r = _HexGrid$_cubicToAxia.r;\n\n            if (tiles[r + radius] === undefined) {\n              tiles[r + radius] = [];\n            }\n            // Merge the passed default properties with some grid meta data\n            var tileProps = Object.assign({}, defaultTileProps, {\n              x: q,\n              y: r,\n              grid: this\n            });\n            tiles[r + radius][q + radius + Math.min(0, r)] = new _Tile2.default(tileProps);\n          }\n        }\n      }\n    }\n    this._tiles = tiles;\n    this._radius = radius;\n    // Build out the index so we can super quickly look up tiles by property\n    this._propertyIndex = new _TilePropertyIndex2.default(this.getTiles());\n  }\n\n  /**\n   * Returns the Tile at axial coordinates (q, r). q can be read as \"column\",\n   * and r can be read as \"row\".\n   * @example\n   * let originTile = myGrid.getTile(0, 0);\n   * @param {number} q - q coordinate of Tile to fetch\n   * @param {number} r - r coordinate of Tile to fetch\n   * @returns {Tile} The tile at the provided coordinates\n   */\n\n\n  _createClass(HexGrid, [{\n    key: \"getTile\",\n    value: function getTile(q, r) {\n      var xOffset = r + this._radius;\n      var yOffset = q + this._radius + Math.min(0, r);\n\n      if (xOffset < 0 || xOffset >= this._tiles.length || yOffset < 0 || yOffset >= this._tiles[xOffset].length) {\n        throw new Error(\"Attempted to access Tile out of bounds at coordinates (\" + q + \", \" + r + \")\");\n      }\n\n      return this._tiles[xOffset][yOffset];\n    }\n\n    /**\n     * Returns an array of all tiles in the HexGrid\n     * @example\n     * let tiles = myGrid.getTiles();\n     * tiles.forEach((tile) => {\n     *   tile.set(\"temperature\", 75).set(\"forecast\", \"sunny\");\n     * });\n     * @returns {Array.Tile} Array of all tiles in this HexGrid\n     */\n\n  }, {\n    key: \"getTiles\",\n    value: function getTiles() {\n      /* this._tiles is just an array of arrays. Reduce to a single dimensional\n       * array by concatenating them all together. */\n      return this._tiles.reduce(function (prevArray, currArray) {\n        return prevArray.concat(currArray);\n      }, []);\n    }\n\n    /**\n     * Returns all tiles that posess the given property or properties\n     * @example\n     * // Returns all tiles that have \"biome\" and \"temperature\" properties\n     * let habitatTiles = grid.getTilesByProperty([\"biome\", \"temperature\"]);\n     * @param {(string | Array.string)} properties - the properties a tile\n     * must posess to be included in the result\n     * @returns {Array.Tile} the tiles that include all of the given\n     * properties\n     */\n\n  }, {\n    key: \"getTilesByProperty\",\n    value: function getTilesByProperty(properties) {\n      return this._propertyIndex.getTilesByProperty(properties);\n    }\n\n    /**\n     * Returns the Tiles that are adjacent to the Tile at the provided (q, r) coordinates.\n     * @example\n     * let neighborsOfOrigin = myGrid.neighborsOf(0, 0);\n     * neighborsOfOrigin.forEach((tile) => {\n     *   tile.set(\"bordersOrigin\", true);\n     * });\n     * @param {number} q - q coordinate of Tile for which to fetch neighbors\n     * @param {number} r - r coordinate of Tile for which to fetch neighbors\n     * @returns {Array.Tile} The array of neighboring Tiles\n     */\n\n  }, {\n    key: \"neighborsOf\",\n    value: function neighborsOf(q, r) {\n      var _this = this;\n\n      return HexGrid._axialUnitDirections.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        var qd = _ref2[0];\n        var rd = _ref2[1];\n\n        try {\n          return _this.getTile(q + qd, r + rd);\n        } catch (e) {\n          return null;\n        }\n      }).filter(function (tile) {\n        return tile !== null;\n      });\n    }\n\n    /**\n     * Calculates the distance between two (q, r) coordinates in tiles\n     * @example\n     * let myGrid = new HexGrid(2);\n     * let distanceFromCenterToEdge = myGrid.distanceBetween(0, 0, 2, -2); // 2\n     * @param {number} q1 - q coordinate of first tile\n     * @param {number} r1 - r coordinate of first tile\n     * @param {number} q2 - q coordinate of second tile\n     * @param {number} r2 - r coordinate of second tile\n     * @returns {number} The distance between the provided coordinates in tiles\n     */\n\n  }, {\n    key: \"distanceBetween\",\n    value: function distanceBetween(q1, r1, q2, r2) {\n      var x1 = void 0,\n          y1 = void 0,\n          z1 = void 0,\n          x2 = void 0,\n          y2 = void 0,\n          z2 = void 0;\n\n      var _HexGrid$_axialToCubi = HexGrid._axialToCubic(q1, r1);\n\n      x1 = _HexGrid$_axialToCubi.x;\n      y1 = _HexGrid$_axialToCubi.y;\n      z1 = _HexGrid$_axialToCubi.z;\n\n      var _HexGrid$_axialToCubi2 = HexGrid._axialToCubic(q2, r2);\n\n      x2 = _HexGrid$_axialToCubi2.x;\n      y2 = _HexGrid$_axialToCubi2.y;\n      z2 = _HexGrid$_axialToCubi2.z;\n\n      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));\n    }\n  }]);\n\n  return HexGrid;\n}();\n\n// The six unit directions in the axial coordinate system\n\n\nHexGrid._axialUnitDirections = [[1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]];\n\n// The six unit directions in the cubic coordinate system\nHexGrid._cubicUnitDirections = [[1, -1, 0], [1, 0, -1], [0, 1, -1], [-1, 1, 0], [-1, 0, 1], [0, -1, 1]];\n\n// Internal helper function for converting from axial coordinates to cubic\nHexGrid._axialToCubic = function (q, r) {\n  return {\n    x: q,\n    z: r,\n    y: -q - r\n  };\n};\n\n// Internal helper function for converting from cubic coordinates to axial\nHexGrid._cubicToAxial = function (x, y, z) {\n  return {\n    q: x,\n    r: z\n  };\n};\n\nexports.default = HexGrid;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/grid/HexGrid.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/modules/grid/HexGrid.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _wolfy87Eventemitter = __webpack_require__(9);\n\nvar _wolfy87Eventemitter2 = _interopRequireDefault(_wolfy87Eventemitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * A Tile is nothing more than a wrapper around a stanard JavaScript object,\n * and represents the state at a discrete location within a grid\n */\n\nvar Tile = function (_EventEmitter) {\n  _inherits(Tile, _EventEmitter);\n\n  /**\n   * Creates a new tile with initial properties. Note that the given initial\n   * properties will be copied *by value* into each tile. What this means is\n   * that inner objects of the initial properties object are *not* deep copied.\n   * @example\n   * const hotTile = new Tile({\n   *   temperature: 110,\n   *   biome: \"desert\"\n   * });\n   * @param {Object} [initialProperties={}] - Initial properties of the Tile\n   */\n\n  function Tile() {\n    var initialProperties = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Tile);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Tile).call(this));\n\n    _this._state = Object.assign({}, initialProperties);\n    return _this;\n  }\n\n  /**\n   * Returns the specified property's value\n   * @example\n   * let temperature = hotTile.get(\"temperature\");\n   * @param {string} key - Name of the property\n   * @returns {*} Value of property at `key`, or undefined if property not found\n   */\n\n\n  _createClass(Tile, [{\n    key: \"get\",\n    value: function get(key) {\n      return this._state[key];\n    }\n\n    /**\n     * Returns true if this Tile has the given key, false otherwise\n     * @param {string} key - the key to check\n     * @returns {boolean} True if the Tile has the given property, false\n     * otherwise\n     */\n\n  }, {\n    key: \"hasProperty\",\n    value: function hasProperty(key) {\n      return this._state.hasOwnProperty(key);\n    }\n\n    /**\n     * Sets the specified property's value, or creates and sets the property if it\n     * does not yet exist.\n     * @example\n     * hotTile.set(\"vegetation\", [\"cactus\", \"tumbleweed\", \"wildflowers\"]);\n     * //Chaining\n     * hotTile.set(\"one\", 1).set(\"two\", 2).set(\"three\", 3);\n     * @fires Tile#propertyAdded\n     * @param {string} key - Name of the property to set/create\n     * @param {*} value - Value of the property\n     * @returns {Tile} The Tile object\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var alreadyHadProperty = this.hasProperty(key);\n      this._state[key] = value;\n      if (!alreadyHadProperty) {\n        /**\n         * Fired when a new property is added to a tile. It is NOT fired when\n         * a property is solely modified.\n         * @event Tile#propertyAdded\n         * @type {object}\n         * @property {Tile} tile - the tile that was modified\n         * @property {string} property - the property that was added\n         */\n        this.emitEvent(\"propertyAdded\", [{ tile: this, property: key }]);\n      }\n      return this;\n    }\n\n    /**\n     * Deletes the specified property, removing it from the Tile completely\n     * @example\n     * let didDeleteSomething = hotTile.delete(\"temperature\");\n     * @fires Tile#propertyDeleted\n     * @param {string} key - Name of the property to delete\n     * @returns {boolean} True if an item was actually deleted, false otherwise\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      if (this._state.hasOwnProperty(key)) {\n        delete this._state[key];\n        /**\n         * Fired when a property is deleted from a tile\n         * @event Tile#propertyDeleted\n         * @type {object}\n         * @property {Tile} tile - the tile that was modified\n         * @property {string} property - the property that was deleted\n         */\n        this.emitEvent(\"propertyDeleted\", [{ tile: this, property: key }]);\n        return true;\n      }\n      return false;\n    }\n  }]);\n\n  return Tile;\n}(_wolfy87Eventemitter2.default);\n\nexports.default = Tile;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/grid/Tile.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/modules/grid/Tile.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter v4.2.11 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - http://oli.me.uk/\n * @preserve\n */\n\n;(function () {\n    'use strict';\n\n    /**\n     * Class for managing events.\n     * Can be extended to provide event functionality in other classes.\n     *\n     * @class EventEmitter Manages event registering and emitting.\n     */\n    function EventEmitter() {}\n\n    // Shortcuts to improve speed and size\n    var proto = EventEmitter.prototype;\n    var exports = this;\n    var originalGlobalValue = exports.EventEmitter;\n\n    /**\n     * Finds the index of the listener for the event in its storage array.\n     *\n     * @param {Function[]} listeners Array of listeners to search through.\n     * @param {Function} listener Method to look for.\n     * @return {Number} Index of the specified listener, -1 if not found\n     * @api private\n     */\n    function indexOfListener(listeners, listener) {\n        var i = listeners.length;\n        while (i--) {\n            if (listeners[i].listener === listener) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Alias a method while keeping the context correct, to allow for overwriting of target method.\n     *\n     * @param {String} name The name of the target method.\n     * @return {Function} The aliased method\n     * @api private\n     */\n    function alias(name) {\n        return function aliasClosure() {\n            return this[name].apply(this, arguments);\n        };\n    }\n\n    /**\n     * Returns the listener array for the specified event.\n     * Will initialise the event object and listener arrays if required.\n     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n     * Each property in the object response is an array of listener functions.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Function[]|Object} All listener functions for the event.\n     */\n    proto.getListeners = function getListeners(evt) {\n        var events = this._getEvents();\n        var response;\n        var key;\n\n        // Return a concatenated array of all matching events if\n        // the selector is a regular expression.\n        if (evt instanceof RegExp) {\n            response = {};\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    response[key] = events[key];\n                }\n            }\n        }\n        else {\n            response = events[evt] || (events[evt] = []);\n        }\n\n        return response;\n    };\n\n    /**\n     * Takes a list of listener objects and flattens it into a list of listener functions.\n     *\n     * @param {Object[]} listeners Raw listener objects.\n     * @return {Function[]} Just the listener functions.\n     */\n    proto.flattenListeners = function flattenListeners(listeners) {\n        var flatListeners = [];\n        var i;\n\n        for (i = 0; i < listeners.length; i += 1) {\n            flatListeners.push(listeners[i].listener);\n        }\n\n        return flatListeners;\n    };\n\n    /**\n     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Object} All listener functions for an event in an object.\n     */\n    proto.getListenersAsObject = function getListenersAsObject(evt) {\n        var listeners = this.getListeners(evt);\n        var response;\n\n        if (listeners instanceof Array) {\n            response = {};\n            response[evt] = listeners;\n        }\n\n        return response || listeners;\n    };\n\n    /**\n     * Adds a listener function to the specified event.\n     * The listener will not be added if it is a duplicate.\n     * If the listener returns true then it will be removed after it is called.\n     * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListener = function addListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var listenerIsWrapped = typeof listener === 'object';\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n                listeners[key].push(listenerIsWrapped ? listener : {\n                    listener: listener,\n                    once: false\n                });\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of addListener\n     */\n    proto.on = alias('addListener');\n\n    /**\n     * Semi-alias of addListener. It will add a listener that will be\n     * automatically removed after its first execution.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addOnceListener = function addOnceListener(evt, listener) {\n        return this.addListener(evt, {\n            listener: listener,\n            once: true\n        });\n    };\n\n    /**\n     * Alias of addOnceListener.\n     */\n    proto.once = alias('addOnceListener');\n\n    /**\n     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n     * You need to tell it what event names should be matched by a regex.\n     *\n     * @param {String} evt Name of the event to create.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvent = function defineEvent(evt) {\n        this.getListeners(evt);\n        return this;\n    };\n\n    /**\n     * Uses defineEvent to define multiple events.\n     *\n     * @param {String[]} evts An array of event names to define.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvents = function defineEvents(evts) {\n        for (var i = 0; i < evts.length; i += 1) {\n            this.defineEvent(evts[i]);\n        }\n        return this;\n    };\n\n    /**\n     * Removes a listener function from the specified event.\n     * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to remove the listener from.\n     * @param {Function} listener Method to remove from the event.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListener = function removeListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var index;\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key)) {\n                index = indexOfListener(listeners[key], listener);\n\n                if (index !== -1) {\n                    listeners[key].splice(index, 1);\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeListener\n     */\n    proto.off = alias('removeListener');\n\n    /**\n     * Adds listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n     * You can also pass it a regular expression to add the array of listeners to all events that match it.\n     * Yeah, this function does quite a bit. That's probably a bad thing.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListeners = function addListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(false, evt, listeners);\n    };\n\n    /**\n     * Removes listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be removed.\n     * You can also pass it a regular expression to remove the listeners from all events that match it.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListeners = function removeListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(true, evt, listeners);\n    };\n\n    /**\n     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n     * The first argument will determine if the listeners are removed (true) or added (false).\n     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be added/removed.\n     * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n     *\n     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n        var i;\n        var value;\n        var single = remove ? this.removeListener : this.addListener;\n        var multiple = remove ? this.removeListeners : this.addListeners;\n\n        // If evt is an object then pass each of its properties to this method\n        if (typeof evt === 'object' && !(evt instanceof RegExp)) {\n            for (i in evt) {\n                if (evt.hasOwnProperty(i) && (value = evt[i])) {\n                    // Pass the single listener straight through to the singular method\n                    if (typeof value === 'function') {\n                        single.call(this, i, value);\n                    }\n                    else {\n                        // Otherwise pass back to the multiple function\n                        multiple.call(this, i, value);\n                    }\n                }\n            }\n        }\n        else {\n            // So evt must be a string\n            // And listeners must be an array of listeners\n            // Loop over it and pass each one to the multiple method\n            i = listeners.length;\n            while (i--) {\n                single.call(this, evt, listeners[i]);\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Removes all listeners from a specified event.\n     * If you do not specify an event then all listeners will be removed.\n     * That means every event will be emptied.\n     * You can also pass a regex to remove all events that match it.\n     *\n     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeEvent = function removeEvent(evt) {\n        var type = typeof evt;\n        var events = this._getEvents();\n        var key;\n\n        // Remove different things depending on the state of evt\n        if (type === 'string') {\n            // Remove all listeners for the specified event\n            delete events[evt];\n        }\n        else if (evt instanceof RegExp) {\n            // Remove all events matching the regex.\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    delete events[key];\n                }\n            }\n        }\n        else {\n            // Remove all listeners in all events\n            delete this._events;\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeEvent.\n     *\n     * Added to mirror the node API.\n     */\n    proto.removeAllListeners = alias('removeEvent');\n\n    /**\n     * Emits an event of your choice.\n     * When emitted, every listener attached to that event will be executed.\n     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n     * So they will not arrive within the array on the other side, they will be separate.\n     * You can also pass a regular expression to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {Array} [args] Optional array of arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emitEvent = function emitEvent(evt, args) {\n        var listenersMap = this.getListenersAsObject(evt);\n        var listeners;\n        var listener;\n        var i;\n        var key;\n        var response;\n\n        for (key in listenersMap) {\n            if (listenersMap.hasOwnProperty(key)) {\n                listeners = listenersMap[key].slice(0);\n                i = listeners.length;\n\n                while (i--) {\n                    // If the listener returns true then it shall be removed from the event\n                    // The function is executed either with a basic call or an apply if there is an args array\n                    listener = listeners[i];\n\n                    if (listener.once === true) {\n                        this.removeListener(evt, listener.listener);\n                    }\n\n                    response = listener.listener.apply(this, args || []);\n\n                    if (response === this._getOnceReturnValue()) {\n                        this.removeListener(evt, listener.listener);\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of emitEvent\n     */\n    proto.trigger = alias('emitEvent');\n\n    /**\n     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {...*} Optional additional arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emit = function emit(evt) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return this.emitEvent(evt, args);\n    };\n\n    /**\n     * Sets the current value to check against when executing listeners. If a\n     * listeners return value matches the one set here then it will be removed\n     * after execution. This value defaults to true.\n     *\n     * @param {*} value The new value to check for when executing listeners.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.setOnceReturnValue = function setOnceReturnValue(value) {\n        this._onceReturnValue = value;\n        return this;\n    };\n\n    /**\n     * Fetches the current value to check against when executing listeners. If\n     * the listeners return value matches this one then it should be removed\n     * automatically. It will return true by default.\n     *\n     * @return {*|Boolean} The current value to check for or the default, true.\n     * @api private\n     */\n    proto._getOnceReturnValue = function _getOnceReturnValue() {\n        if (this.hasOwnProperty('_onceReturnValue')) {\n            return this._onceReturnValue;\n        }\n        else {\n            return true;\n        }\n    };\n\n    /**\n     * Fetches the events object and creates one if required.\n     *\n     * @return {Object} The events storage object.\n     * @api private\n     */\n    proto._getEvents = function _getEvents() {\n        return this._events || (this._events = {});\n    };\n\n    /**\n     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n     *\n     * @return {Function} Non conflicting EventEmitter class.\n     */\n    EventEmitter.noConflict = function noConflict() {\n        exports.EventEmitter = originalGlobalValue;\n        return EventEmitter;\n    };\n\n    // Expose the class either via AMD, CommonJS or the global object\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return EventEmitter;\n        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else if (typeof module === 'object' && module.exports){\n        module.exports = EventEmitter;\n    }\n    else {\n        exports.EventEmitter = EventEmitter;\n    }\n}.call(this));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/wolfy87-eventemitter/EventEmitter.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/wolfy87-eventemitter/EventEmitter.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MultiStringHashMap = __webpack_require__(11);\n\nvar _MultiStringHashMap2 = _interopRequireDefault(_MultiStringHashMap);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Builds an index of {@link Tiles} for fast lookup by property\n */\n\nvar TilePropertyIndex = function () {\n  /**\n  * Creates a new TilePropertyIndex with the given array of tiles.\n  * Note: the index is built on demand. Constructing a new TilePropertyIndex\n  * does not actually build a complete index (which would be expensive),\n  * but instead the indices are built as needed.\n  * @example\n  * const tiles = [\n  *   new Tile(),\n  *   new Tile(),\n  *   new Tile()\n  * ];\n  * const tileIndex = new TilePropertyIndex(tileIndex);\n  * @param {Array.Tile} tiles - the array of tiles for which to build\n  * an index by tile property\n  */\n\n  function TilePropertyIndex(tiles) {\n    var _this = this;\n\n    _classCallCheck(this, TilePropertyIndex);\n\n    /**\n     * @type {Array.Tile}\n     * @private\n     */\n    this._tiles = tiles;\n\n    // Register for all tile events so that we can keep the index up to\n    // date upon any changes.\n    // Note that we need to bind `this`, because within the event handler\n    // `this` would normally refer to the Tile itself.\n    this._tiles.forEach(function (tile) {\n      tile.addListener(\"propertyAdded\", _this.onTilePropertyAdded.bind(_this));\n      tile.addListener(\"propertyDeleted\", _this.onTilePropertyDeleted.bind(_this));\n    });\n\n    /**\n     * @type {MultiStringHashMap}\n     * @private\n     */\n    this._index = new _MultiStringHashMap2.default();\n  }\n\n  /**\n   * Returns all tiles that posess the given property or properties\n   * @example\n   * // Returns all tiles that have \"biome\" and \"temperature\" properties\n   * let habitatTiles = tileIndex.getTilesByProperty([\"biome\", \"temperature\"]);\n   * @param {(string | Array.string)} properties - the properties a tile\n   * must posess to be included in the result\n   * @returns {Array.Tile} the tiles that include all of the given\n   * properties\n   */\n\n\n  _createClass(TilePropertyIndex, [{\n    key: \"getTilesByProperty\",\n    value: function getTilesByProperty(properties) {\n      // If the index does exist, we don't need to build it. We can assume\n      // that the index has been kept up to date.\n      if (!this._index.hasKey(properties)) {\n        this._buildIndex(properties);\n      }\n      return this._index.get(properties);\n    }\n\n    /**\n     * Event handler called when a property is added to a tile to keep the\n     * relevant indices up to date\n     * @param {object} e - the event object\n     * @param {Tile} e.tile - the tile that is being updated\n     * @param {string} e.property - the property that was added\n     */\n\n  }, {\n    key: \"onTilePropertyAdded\",\n    value: function onTilePropertyAdded(_ref) {\n      var _this2 = this;\n\n      var tile = _ref.tile;\n      var property = _ref.property;\n\n      // Check for indices that the tile should now be included in\n      var index = void 0;\n      this._index.keys().forEach(function (key) {\n        // If this tile matches this index, but is NOT included in it,\n        // add it to this index\n        if (_this2._tileMatchesIndex(tile, key)) {\n          index = _this2._index.get(key);\n          if (!index.includes(tile)) {\n            index.push(tile);\n          }\n        }\n      });\n    }\n\n    /**\n     * Event handler called when a property is deleted from a tile to keep the\n     * relevant indices up to date\n     * @param {object} e - the event object\n     * @param {Tile} e.tile - the tile that is being updated\n     * @param {string} e.property - the property that was deleted\n     */\n\n  }, {\n    key: \"onTilePropertyDeleted\",\n    value: function onTilePropertyDeleted(_ref2) {\n      var _this3 = this;\n\n      var tile = _ref2.tile;\n      var property = _ref2.property;\n\n      // Check for indices that the tile should now be removed from\n      var index = void 0;\n      this._index.keys().forEach(function (key) {\n        // If this tile does NOT match this index, but it is included in it,\n        // remove it from that index\n        if (!_this3._tileMatchesIndex(tile, key)) {\n          index = _this3._index.get(key);\n          if (index.includes(tile)) {\n            index.splice(index.indexOf(tile), 1);\n          }\n        }\n      });\n    }\n\n    /**\n     * Private function that builds the index for the given group of\n     * properties. Loops over the _tiles array, and if a Tile contains\n     * all of the given properties, it is added to this index.\n     * @private\n     * @param {(string | Array.string)} properties - the property\n     * index to build\n     */\n\n  }, {\n    key: \"_buildIndex\",\n    value: function _buildIndex(properties) {\n      var _this4 = this;\n\n      // Initialize the index to an empty array\n      var index = [];\n\n      // Try and add every tile to the index\n      this._tiles.forEach(function (tile) {\n        if (_this4._tileMatchesIndex(tile, properties)) {\n          index.push(tile);\n        }\n      });\n\n      this._index.set(properties, index);\n    }\n\n    /**\n     * Returns true if the given tile contains all of the given properties\n     * @private\n     * @param {Tile} tile - the tile to check\n     * @param {(string | Array.string)} properties - the props to check\n     * against\n     */\n\n  }, {\n    key: \"_tileMatchesIndex\",\n    value: function _tileMatchesIndex(tile, properties) {\n      if (typeof properties === \"string\") {\n        return tile.hasProperty(properties);\n      } else if (properties.constructor === Array) {\n        return properties.every(function (prop) {\n          return tile.hasProperty(prop);\n        });\n      }\n      return false;\n    }\n  }]);\n\n  return TilePropertyIndex;\n}();\n\nexports.default = TilePropertyIndex;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/grid/TilePropertyIndex.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/modules/grid/TilePropertyIndex.js?");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A key/value store where keys can be a single string, or an array of strings.\n */\n\nvar MultiStringHashMap = function () {\n  /**\n   * Constructs a new, empty MultiStringHashMap\n   */\n\n  function MultiStringHashMap() {\n    _classCallCheck(this, MultiStringHashMap);\n\n    /**\n     * Internal representation of the key/value store.\n     * @type {object}\n     * @private\n     */\n    this._map = {};\n  }\n\n  /**\n   * Returns a hash value for the given string or array of strings. Hash value\n   * will be the same for an array containing the same strings regardless of\n   * order. In other words, `[\"one\", \"two\"]` will hash to the same value as\n   * `[\"two\", \"one\"]`.\n   * @private\n   * @param {string | Array.string} potentialKey - string or array of strings\n   * to hash\n   * @returns {string} Hashed value\n   */\n\n\n  _createClass(MultiStringHashMap, [{\n    key: \"_hash\",\n    value: function _hash(potentialKey) {\n      if (typeof potentialKey === \"string\") {\n        return \"$\" + potentialKey;\n      } else if (potentialKey.constructor === Array) {\n        return \"$\" + potentialKey.sort().join(\",\");\n      } else {\n        throw new TypeError(\"MultiStringHashMap#_hash bad argument\");\n      }\n    }\n\n    /**\n     * Returns the value stored at the given key\n     * @example\n     * const shinyMetallicWeapons = myHash.get([\"shiny\", \"metallic\", \"sharp\"]);\n     * @param {string | Array.string} key - key to lookup\n     * @returns {*} Value at the given key\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this._map[this._hash(key)];\n    }\n\n    /**\n     * Returns true if the given key exists in the map, false otherwise\n     * @example\n     * myHash.set([\"tiny\", \"spherical\"], [\"marbles\", \"peas\"]);\n     * myHash.hasKey([\"tiny\", \"spherical\"]); // true\n     * @param {(string | Array.string)} key - key for which to check\n     * existence\n     * @returns {boolean} True if key exists, false otherwise\n     */\n\n  }, {\n    key: \"hasKey\",\n    value: function hasKey(key) {\n      return this._map.hasOwnProperty(this._hash(key));\n    }\n\n    /**\n     * Returns an array of all keys in the hash map\n     * @example\n     * const myHash = new MultiStringHashMap();\n     * myHash.set([\"one\", \"two\", \"three\"], [1, 2, 3]);\n     * myHash.set(\"four\", 4);\n     * let keys = myHash.keys(); // [ [\"one\", \"two\", \"three\"], \"four\" ]\n     * @returns {Array} the array of keys\n     */\n\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      return Object.keys(this._map).map(function (key) {\n        if (key.indexOf(\",\") < 0) {\n          return key.slice(1);\n        } else {\n          return key.slice(1).split(\",\");\n        }\n      });\n    }\n\n    /**\n     * Sets a value at the given key, or creates and sets the value at the given\n     * key if it does not exist\n     * @example\n     * const myHash = new MultiStringHashMap();\n     * myHash.set([\"shiny\", \"metallic\", \"sharp\"], [\"sword\", \"knife\", \"dagger\"]);\n     * @param {string | Array.string} key - key to store the value at\n     * @param {*} value - the value to store\n     * @returns The MultiStringHashMap\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this._map[this._hash(key)] = value;\n      return this;\n    }\n\n    /**\n     * Deletes the given key\n     * @example\n     * let wasDeleted = myHash.delete([\"no\", \"longer\", \"needed\"]);\n     * // myHash.get([\"no\", \"longer\", \"needed\"]) === undefined\n     * @param {string | Array.string} key - key to delete\n     * @returns {boolean} True if a key was actually deleted, false otherwise\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var hash = this._hash(key);\n      if (this._map.hasOwnProperty(hash)) {\n        delete this._map[hash];\n        return true;\n      }\n      return false;\n    }\n  }]);\n\n  return MultiStringHashMap;\n}();\n\nexports.default = MultiStringHashMap;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/modules/util/MultiStringHashMap.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/modules/util/MultiStringHashMap.js?");

/***/ }
/******/ ]);